// backend/controllers/responseController.js
import { getConnection } from '../db.js';
import sql from 'mssql';

// Utilidad: verificar si existe una columna
async function columnExists(pool, schema, table, column) {
  const q = `SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA=@s AND TABLE_NAME=@t AND COLUMN_NAME=@c`;
  const rs = await pool
    .request()
    .input('s', sql.NVarChar, schema)
    .input('t', sql.NVarChar, table)
    .input('c', sql.NVarChar, column)
    .query(q);
  return rs.recordset.length > 0;
}

// Calcula suma total y subescalas (si existen reglas en dbo.subescalas). También reconoce LSAS por sufijos |miedo y |evitacion en questionId.
async function calculateScores(surveyId, answers) {
  const pool = await getConnection();

  // Orden de preguntas (para usar posibles rangos en subescalas)
  const qRes = await pool
    .request()
    .input('sid', sql.Int, surveyId)
    .query(`SELECT p.id FROM dbo.preguntas p WHERE p.id_encuesta=@sid ORDER BY p.id`);

  const orderMap = new Map(); // id -> índice (1..N)
  qRes.recordset.forEach((row, idx) => orderMap.set(String(row.id), idx + 1));

  // Respuestas numéricas
  const numericAnswers = (answers || [])
    .map(a => ({ qid: String(a.questionId), value: Number(a.answer) }))
    .filter(a => !Number.isNaN(a.value));

  const total = numericAnswers.reduce((s, a) => s + a.value, 0);

  const subscales = {};

  // Reconocer LSAS por sufijos en questionId
  const fear = numericAnswers
    .filter(a => a.qid.toLowerCase().includes('|miedo'))
    .reduce((s, a) => s + a.value, 0);
  const avoid = numericAnswers
    .filter(a => a.qid.toLowerCase().includes('|evitacion'))
    .reduce((s, a) => s + a.value, 0);
  if (fear > 0 || avoid > 0) {
    subscales['Miedo/ansiedad'] = fear;
    subscales['Evitación'] = avoid;
  }

  // Subescalas por rango desde la BD
  const ssRes = await pool
    .request()
    .input('sid', sql.Int, surveyId)
    .query(`SELECT id, nombre, rango_items FROM dbo.subescalas WHERE id_encuesta=@sid ORDER BY id`);

  for (const row of ssRes.recordset || []) {
    const [a, b] = String(row.rango_items).split('-');
    const start = parseInt(a, 10);
    const end = parseInt(b, 10);
    if (Number.isNaN(start) || Number.isNaN(end)) continue;

    const score = numericAnswers.reduce((s, ans) => {
      const baseId = ans.qid.split('|')[0];
      const idx = orderMap.get(baseId);
      if (!idx) return s;
      return (idx >= start && idx <= end) ? s + ans.value : s;
    }, 0);

    if (typeof subscales[row.nombre] === 'undefined') subscales[row.nombre] = score;
    else subscales[row.nombre] += score;
  }

  return { total, subscales };
}

// Para persistir detalle de subescalas (si existe tabla resultados_subescalas)
async function calculateSubscaleRows(surveyId, answers) {
  const pool = await getConnection();

  const qRes = await pool
    .request()
    .input('sid', sql.Int, surveyId)
    .query(`SELECT p.id FROM dbo.preguntas p WHERE p.id_encuesta=@sid ORDER BY p.id`);
  const orderMap = new Map();
  qRes.recordset.forEach((row, idx) => orderMap.set(String(row.id), idx + 1));

  const numericAnswers = (answers || [])
    .map(a => ({ qid: String(a.questionId), value: Number(a.answer) }))
    .filter(a => !Number.isNaN(a.value));

  const ssRes = await pool
    .request()
    .input('sid', sql.Int, surveyId)
    .query(`SELECT id, nombre, rango_items FROM dbo.subescalas WHERE id_encuesta=@sid ORDER BY id`);

  const rows = [];
  for (const row of ssRes.recordset || []) {
    const [a, b] = String(row.rango_items).split('-');
    const start = parseInt(a, 10);
    const end = parseInt(b, 10);
    if (Number.isNaN(start) || Number.isNaN(end)) continue;
    const score = numericAnswers.reduce((s, ans) => {
      const baseId = ans.qid.split('|')[0];
      const idx = orderMap.get(baseId);
      if (!idx) return s;
      return (idx >= start && idx <= end) ? s + ans.value : s;
    }, 0);
    rows.push({ id_subescala: row.id, puntaje: score });
  }
  return rows;
}

// POST /api/responses
const createResponse = async (req, res) => {
  try {
    const { surveyId, userId, answers } = req.body || {};
    const sid = parseInt(surveyId, 10);
    const uid = parseInt(userId, 10);
    if (Number.isNaN(sid) || Number.isNaN(uid) || !Array.isArray(answers)) {
      return res.status(400).json({ message: 'Payload inválido.' });
    }

    const pool = await getConnection();
    const hasResultadoFK = await columnExists(pool, 'dbo', 'respuestas', 'id_resultado');
    const hasTotalCol = await columnExists(pool, 'dbo', 'resultados', 'puntaje_total');
    const hasResumenCol = await columnExists(pool, 'dbo', 'resultados', 'resumen_json');

    const totals = await calculateScores(sid, answers);
    const subRows = await calculateSubscaleRows(sid, answers);

    const tx = new sql.Transaction(pool);
    await tx.begin();
    try {
      const reqTx = new sql.Request(tx);
      const ins = await reqTx
        .input('fecha', sql.DateTime, new Date())
        .input('id_usuario', sql.Int, uid)
        .input('id_encuesta', sql.Int, sid)
        .query(`INSERT INTO dbo.resultados (fecha, id_usuario, id_encuesta)
                OUTPUT INSERTED.id VALUES (@fecha, @id_usuario, @id_encuesta)`);
      const resultadoId = ins.recordset[0].id;

      if (hasTotalCol) {
        await reqTx
          .input('rid', sql.Int, resultadoId)
          .input('total', sql.Int, totals.total)
          .query('UPDATE dbo.resultados SET puntaje_total=@total WHERE id=@rid');
      }
      if (hasResumenCol) {
        await reqTx
          .input('rid2', sql.Int, resultadoId)
          .input('json', sql.NVarChar(sql.MAX), JSON.stringify(totals.subscales || {}))
          .query('UPDATE dbo.resultados SET resumen_json=@json WHERE id=@rid2');
      }

      // Persistir subescalas si la tabla existe
      const hasRS = (await reqTx.query(`SELECT 1 FROM sys.objects WHERE object_id = OBJECT_ID('dbo.resultados_subescalas') AND type='U'`)).recordset.length > 0;
      if (hasRS) {
        for (const r of subRows) {
          await new sql.Request(tx)
            .input('id_resultado', sql.Int, resultadoId)
            .input('id_subescala', sql.Int, r.id_subescala)
            .input('puntaje', sql.Int, r.puntaje)
            .query('INSERT INTO dbo.resultados_subescalas (id_resultado, id_subescala, puntaje) VALUES (@id_resultado, @id_subescala, @puntaje)');
        }
      }

      // Respuestas
      for (const a of answers) {
        const qKey = String(a.questionId);
        const [qidStr, subLabelRaw] = qKey.split('|');
        const qid = parseInt(qidStr, 10);
        if (Number.isNaN(qid)) continue;

        const valueNum = Number(a.answer);
        let optionId = null;
        if (!Number.isNaN(valueNum)) {
          let query = 'SELECT TOP 1 id FROM dbo.opciones_respuesta WHERE id_pregunta=@qid AND valor=@val';
          const r = new sql.Request(tx).input('qid', sql.Int, qid).input('val', sql.NVarChar, String(valueNum));
          if (subLabelRaw) {
            query += ' AND LOWER(COALESCE(subescala, ' + "''" + ')) = @sub';
            r.input('sub', sql.NVarChar, subLabelRaw.toLowerCase());
          }
          const or = await r.query(query);
          optionId = or.recordset[0]?.id ?? null;
        }

        const baseReq = new sql.Request(tx)
          .input('respuesta', sql.NVarChar(sql.MAX), String(a.answer))
          .input('id_pregunta', sql.Int, qid)
          .input('id_usuario', sql.Int, uid);

        if (hasResultadoFK) baseReq.input('id_resultado', sql.Int, resultadoId);
        if (!Number.isNaN(valueNum)) baseReq.input('valor_numerico', sql.Int, valueNum);
        if (optionId !== null) baseReq.input('id_opcion_respuesta', sql.Int, optionId);

        // Intentar insertar con columnas extendidas; si falla, degradar
        try {
          await baseReq.query(`INSERT INTO dbo.respuestas (respuesta, id_pregunta, id_usuario, ${hasResultadoFK ? 'id_resultado, ' : ''}valor_numerico, id_opcion_respuesta)
                               VALUES (@respuesta, @id_pregunta, @id_usuario, ${hasResultadoFK ? '@id_resultado, ' : ''}@valor_numerico, @id_opcion_respuesta)`);
        } catch {
          const simple = new sql.Request(tx)
            .input('respuesta', sql.NVarChar(sql.MAX), String(a.answer))
            .input('id_pregunta', sql.Int, qid)
            .input('id_usuario', sql.Int, uid);
          if (hasResultadoFK) {
            simple.input('id_resultado', sql.Int, resultadoId);
            await simple.query('INSERT INTO dbo.respuestas (respuesta, id_pregunta, id_usuario, id_resultado) VALUES (@respuesta, @id_pregunta, @id_usuario, @id_resultado)');
          } else {
            await simple.query('INSERT INTO dbo.respuestas (respuesta, id_pregunta, id_usuario) VALUES (@respuesta, @id_pregunta, @id_usuario)');
          }
        }
      }

      await tx.commit();

      // Clasificación (opcional) para algunas escalas sin promedios
      try {
        const info = await pool
          .request()
          .input('sid', sql.Int, sid)
          .query('SELECT titulo FROM dbo.encuestas WHERE id=@sid');
        const titulo = (info.recordset?.[0]?.titulo || '').toLowerCase();

        if (titulo.includes('rosenberg')) {
          const t = totals.total || 0;
          let cls = 'Autoestima moderada';
          if (t <= 25) cls = 'Baja autoestima';
          else if (t >= 36) cls = 'Alta autoestima';
          totals.classification = cls;
        } else if (titulo.includes('liebow') || titulo.includes('lsas')) {
          const t = totals.total || 0;
          let cls = 'Leve ansiedad social';
          if (t >= 82) cls = 'Grave Ansiedad Social';
          else if (t >= 52) cls = 'Moderada Ansiedad social';
          totals.classification = cls;
        } else if (titulo.includes('horwitz') || String(sid) === '6') {
          const t = totals.total || 0;
          let lvl = 'Bajo';
          if (t >= 90) lvl = 'Alto';
          else if (t >= 70) lvl = 'Moderado';
          totals.classification = 'Ansiedad ' + lvl;
        }
      } catch {}

      const payload = {
        id: String(resultadoId),
        surveyId: String(surveyId),
        userId: String(userId),
        answers,
        totals,
        completedAt: new Date().toISOString(),
      };
      return res.status(201).json(payload);
    } catch (err) {
      await tx.rollback();
      console.error('TX error al guardar respuesta:', err);
      return res.status(500).json({ message: 'Error guardando respuesta.' });
    }
  } catch (err) {
    console.error('Error al crear respuesta:', err);
    res.status(500).json({ message: 'Error interno del servidor al guardar respuesta.' });
  }
};

// GET /api/responses (admin)
const getResponses = async (_req, res) => {
  try {
    const pool = await getConnection();
    const hasResultadoFK = await columnExists(pool, 'dbo', 'respuestas', 'id_resultado');

    const rs = await pool.request().query('SELECT id, fecha, id_usuario, id_encuesta FROM dbo.resultados ORDER BY fecha DESC');
    const list = [];
    for (const row of rs.recordset) {
      let answers = [];
      if (hasResultadoFK) {
        const a = await pool
          .request()
          .input('rid', sql.Int, row.id)
          .query(`SELECT r.respuesta, r.id_pregunta, r.valor_numerico, r.id_opcion_respuesta, o.subescala
                  FROM dbo.respuestas r
                  LEFT JOIN dbo.opciones_respuesta o ON o.id = r.id_opcion_respuesta
                  WHERE r.id_resultado=@rid ORDER BY r.id`);
        answers = a.recordset.map(r => {
          const baseId = String(r.id_pregunta);
          const sub = r.subescala ? '|' + String(r.subescala) : '';
          const qid = baseId + sub;
          const val = r.valor_numerico ?? (isNaN(Number(r.respuesta)) ? r.respuesta : Number(r.respuesta));
          return { questionId: qid, answer: val };
        });
      } else {
        const a = await pool
          .request()
          .input('uid', sql.Int, row.id_usuario)
          .input('sid', sql.Int, row.id_encuesta)
          .query(`SELECT r.respuesta, r.id_pregunta
                  FROM dbo.respuestas r
                  WHERE r.id_usuario=@uid AND r.id_pregunta IN (SELECT p.id FROM dbo.preguntas p WHERE p.id_encuesta=@sid)
                  ORDER BY r.id`);
        answers = a.recordset.map(r => ({ questionId: String(r.id_pregunta), answer: r.respuesta }));
      }

      const totals = await calculateScores(row.id_encuesta, answers);
      // Clasificación básica para LSAS y FLCAS
      try {
        if (answers.some(a => String(a.questionId).includes('|miedo') || String(a.questionId).includes('|evitacion'))) {
          const t = totals.total || 0;
          let cls = 'Leve ansiedad social';
          if (t >= 82) cls = 'Grave Ansiedad Social';
          else if (t >= 52) cls = 'Moderada Ansiedad social';
          totals.classification = cls;
        } else if (String(row.id_encuesta) === '6') {
          const t = totals.total || 0;
          let lvl = 'Bajo';
          if (t >= 90) lvl = 'Alto';
          else if (t >= 70) lvl = 'Moderado';
          totals.classification = 'Ansiedad ' + lvl;
        }
      } catch {}

      list.push({
        id: String(row.id),
        surveyId: String(row.id_encuesta),
        userId: String(row.id_usuario),
        answers,
        totals,
        completedAt: row.fecha,
      });
    }

    res.status(200).json(list);
  } catch (err) {
    console.error('Error al obtener responses:', err);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
};

// GET /api/users/:id/results (usuario)
const getResultsByUser = async (req, res) => {
  try {
    const userId = parseInt(req.params.id, 10);
    if (Number.isNaN(userId)) return res.status(400).json({ message: 'ID de usuario inválido' });

    const pool = await getConnection();
    const hasTotalCol = await columnExists(pool, 'dbo', 'resultados', 'puntaje_total');
    const hasResumenCol = await columnExists(pool, 'dbo', 'resultados', 'resumen_json');

    const rs = await pool
      .request()
      .input('uid', sql.Int, userId)
      .query('SELECT id, fecha, id_encuesta, puntaje_total, resumen_json FROM dbo.resultados WHERE id_usuario=@uid ORDER BY fecha DESC');

    const list = [];
    for (const row of rs.recordset) {
      let totals;
      if (hasTotalCol || hasResumenCol) {
        totals = {
          total: row.puntaje_total ?? 0,
          subscales: row.resumen_json ? JSON.parse(row.resumen_json) : {},
        };
      } else {
        const a = await pool
          .request()
          .input('rid', sql.Int, row.id)
          .query('SELECT id_pregunta, respuesta FROM dbo.respuestas WHERE id_resultado=@rid');
        const answers = a.recordset.map(r => ({ questionId: String(r.id_pregunta), answer: r.respuesta }));
        totals = await calculateScores(row.id_encuesta, answers);
      }

      // Clasificación básica LSAS / FLCAS
      try {
        if (totals && totals.subscales && (typeof totals.subscales['Miedo/ansiedad'] !== 'undefined' || typeof totals.subscales['Evitación'] !== 'undefined')) {
          const t = totals.total || 0;
          let cls = 'Leve ansiedad social';
          if (t >= 82) cls = 'Grave Ansiedad Social';
          else if (t >= 52) cls = 'Moderada Ansiedad social';
          totals.classification = cls;
        } else if (String(row.id_encuesta) === '6') {
          const t = totals.total || 0;
          let lvl = 'Bajo';
          if (t >= 90) lvl = 'Alto';
          else if (t >= 70) lvl = 'Moderado';
          totals.classification = 'Ansiedad ' + lvl;
        }
      } catch {}

      list.push({
        id: String(row.id),
        surveyId: String(row.id_encuesta),
        userId: String(userId),
        answers: [],
        totals,
        completedAt: row.fecha,
      });
    }

    res.status(200).json(list);
  } catch (err) {
    console.error('Error al obtener resultados del usuario:', err);
    res.status(500).json({ message: 'Error interno del servidor.' });
  }
};

export { createResponse, getResponses, getResultsByUser };


